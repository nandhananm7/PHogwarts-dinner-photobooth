<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Photobooth Live — 3 Poses → GIF</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0b0f17;
            --panel: #111827;
            --panel-2: #0f172a;
            --text: #e5e7eb;
            --muted: #9ca3af;
            --accent: #22d3ee;
            --ok: #34d399;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            height: 100%;
            font-family: Inter, sans-serif;
            background: linear-gradient(180deg, var(--bg), #06080f 60%);
            color: var(--text);
        }

        .wrap {
            max-width: 980px;
            margin: 24px auto;
            padding: 16px
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 12px
        }

        .title {
            font-weight: 800;
            font-size: clamp(20px, 3vw, 28px)
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border-radius: 999px;
            background: #0b1326;
            border: 1px solid #22314a;
            font-size: 12px;
            color: #cbd5e1
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px
        }

        .card {
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid #1f2937;
            border-radius: 18px;
            padding: 16px;
            box-shadow: 0 10px 24px rgba(0,0,0,.35)
        }

            .card h3 {
                margin: .2rem 0 .8rem;
                font-size: 16px
            }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: end
        }

        .btn {
            all: unset;
            background: linear-gradient(90deg, var(--accent), #a78bfa);
            color: #00131a;
            font-weight: 700;
            padding: 12px 16px;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 6px 18px rgba(34,211,238,.25)
        }

            .btn.secondary {
                background: #0b1326;
                color: #e5e7eb;
                border: 1px solid #22314a;
                box-shadow: none
            }

            .btn:disabled {
                opacity: .6;
                cursor: not-allowed
            }

        .progress {
            height: 10px;
            background: #0b1326;
            border: 1px solid #22314a;
            border-radius: 999px;
            overflow: hidden
        }

        .bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--ok), #60a5fa)
        }

        .preview {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #05070d;
            border-radius: 14px;
            padding: 12px;
            border: 1px solid #101827;
            position: relative
        }

        canvas {
            max-width: 100%;
            height: 100%;
            background: #000
        }

        footer {
            margin-top: 18px;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap
        }

        a.dl {
            color: #111827;
            background: linear-gradient(90deg, #34d399, #86efac);
            padding: 10px 14px;
            border-radius: 10px;
            font-weight: 700;
            text-decoration: none
        }

        .count {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 72px;
            color: #fff;
            text-shadow: 0 2px 18px rgba(0,0,0,.6);
            pointer-events: none
        }

        .hidden {
            display: none !important
        }

        video {
            display: none
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized@1.0.1/dist/gif.js"></script>
</head>
<body>
    <div class="wrap">
        <header>
            <div>
                <div class="title">Photobooth Live — 3 poses → 1 GIF</div>
                <div class="note">Browser version — 3s lead-in + 3s per pose, fixed layout.</div>
            </div>
            <div class="pill" id="selfcheck-pill">Self-check: running…</div>
        </header>

        <div class="grid">
            <section class="card">
                <h3>Controls</h3>
                <div class="row">
                    <button id="start" class="btn">Start Photobooth</button>
                    <button id="preview" class="btn secondary" disabled>Preview GIF</button>
                    <button id="download" class="btn secondary" disabled>Save GIF</button>

                    <!-- Layout selector -->
                    <label class="pill" style="cursor:pointer">
                        Layout:
                        <select id="layoutSelect" style="all:unset;margin-left:8px;cursor:pointer">
                            <option value="0">Layout A</option>
                            <option value="1">Layout B</option>
                        </select>
                    </label>

                    <span id="hint" class="pill">Camera: not started</span>
                </div>
                <div style="margin-top:12px" class="progress"><div class="bar" id="bar"></div></div>
                <div class="note" id="status">Idle</div>
            </section>

            <section class="card">
                <h3>Live View / Preview</h3>
                <div class="preview">
                    <canvas id="c" width="1080" height="1920"></canvas>
                    <div id="count" class="count hidden"></div>
                </div>
                <footer>
                    <a id="dl" class="dl hidden">Download GIF</a>
                </footer>
            </section>
        </div>

        <video id="cam" playsinline muted></video>
    </div>

    <script type="module">
        // ---------- Config ----------
        const OUT_W = 1080, OUT_H = 1920, FPS = 10, LEAD = 3, CLIP = 3;

        // Two layout presets (same canvas size; different backgrounds + rects)
        const LAYOUTS = [
            {
                name: 'A',
                bg: 'bg1.png',
                rects: [
                    { x: 153, y: 508, w: 630, h: 406 },
                    { x: 153, y: 960, w: 630, h: 406 },
                    { x: 153, y: 1407, w: 630, h: 406 },
                ]
            },
            {
                name: 'B',
                bg: 'bg2.png',
                rects: [
                    { x: 395, y: 425, w: 620, h: 401 },
                    { x: 71, y: 858, w: 620, h: 401 },
                    { x: 395, y: 1296, w: 620, h: 401 },
                ]
            }
        ];

        // ---------- DOM ----------
        const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
        canvas.width = OUT_W; canvas.height = OUT_H;

        const countEl = document.getElementById('count');
        const startBtn = document.getElementById('start');
        const previewBtn = document.getElementById('preview');
        const downloadBtn = document.getElementById('download');
        const dl = document.getElementById('dl');
        const bar = document.getElementById('bar');
        const statusEl = document.getElementById('status');
        const hint = document.getElementById('hint');
        const cam = document.getElementById('cam');
        const layoutSelect = document.getElementById('layoutSelect');

        // ---------- State ----------
        let currentLayoutIdx = 0;
        let geo = { W: OUT_W, H: OUT_H, rects: LAYOUTS[currentLayoutIdx].rects };
        const frames = [[], [], []]; // captured frames per pose
        let mode = 'idle';           // 'idle' | 'recording' | 'preview'
        let currentPose = -1;        // 0..2 while recording
        let rafId = null;

        // ---------- Backgrounds ----------
        const bgImgs = LAYOUTS.map(l => {
            const im = new Image();
            im.crossOrigin = 'anonymous';
            im.src = l.bg;
            return im;
        });
        const bgReady = (idx) => !!bgImgs[idx]?.complete;

        function setLayout(idx) {
            currentLayoutIdx = Number(idx);
            geo = { W: OUT_W, H: OUT_H, rects: LAYOUTS[currentLayoutIdx].rects };
        }
        layoutSelect.addEventListener('change', (e) => setLayout(e.target.value));

        // ---------- Helpers ----------
        function fitCover(sw, sh, dw, dh) {
            const sr = sw / sh, dr = dw / dh;
            let w, h, x, y;
            if (sr > dr) { h = dh; w = h * sr; x = (dw - w) / 2; y = 0; }
            else { w = dw; h = w / sr; x = 0; y = (dh - h) / 2; }
            return { x, y, w, h };
        }

        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
                cam.srcObject = stream; cam.muted = true; cam.playsInline = true;

                await new Promise(r => { cam.onloadedmetadata = r; });
                await cam.play();

                hint.textContent = `Camera: ${cam.videoWidth}×${cam.videoHeight}`;
                statusEl.textContent = 'Camera started';
            } catch (err) {
                statusEl.textContent = 'Camera error: ' + (err?.name || err);
                throw err;
            }
        }

        async function countdown(seconds, label) {
            countEl.classList.remove('hidden');
            for (let s = seconds; s > 0; s--) {
                countEl.textContent = `${label} ${s}`;
                await new Promise(r => setTimeout(r, 1000));
            }
            countEl.classList.add('hidden');
        }

        function drawBackground() {
            if (bgReady(currentLayoutIdx)) {
                const bg = bgImgs[currentLayoutIdx];
                ctx.drawImage(bg, 0, 0, geo.W, geo.H);
            } else {
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, geo.W, geo.H);
            }
        }

        function drawMirroredVideoIntoRect(video, rect) {
            const vw = video.videoWidth, vh = video.videoHeight;
            if (!vw || !vh) return;

            // Fit cover into rect
            const sr = vw / vh, dr = rect.w / rect.h;
            let w, h, x, y;
            if (sr > dr) { h = rect.h; w = h * sr; x = rect.x + (rect.w - w) / 2; y = rect.y; }
            else { w = rect.w; h = w / sr; x = rect.x; y = rect.y + (rect.h - h) / 2; }

            ctx.save();
            ctx.translate(x + w, y);
            ctx.scale(-1, 1);
            ctx.drawImage(video, 0, 0, vw, vh, 0, 0, w, h);
            ctx.restore();
        }

        function drawCompositedFrameIndex(fi) {
            drawBackground();
            geo.rects.forEach((r, i) => {
                const fr = frames[i][fi];
                if (fr) ctx.drawImage(fr, r.x, r.y, r.w, r.h);
            });
        }

        // Always-on live loop (shows latest captured stills + live in active slot)
        function liveLoop() {
            if (mode !== 'preview') {
                drawBackground();

                
                geo.rects.forEach((r, i) => {
                    const last = frames[i].length ? frames[i][frames[i].length - 1] : null;
                    if (last) ctx.drawImage(last, r.x, r.y, r.w, r.h);
                });

                // overlay live video in the active slot while recording
                if (mode === 'recording' && currentPose >= 0) {
                    const r = geo.rects[currentPose];
                    drawMirroredVideoIntoRect(cam, r);
                }
            }
            rafId = requestAnimationFrame(liveLoop);
        }
        if (!rafId) rafId = requestAnimationFrame(liveLoop);

        async function captureClip(i) {
            const rect = geo.rects[i];
            const off = document.createElement('canvas'); off.width = rect.w; off.height = rect.h;
            const octx = off.getContext('2d');

            const n = CLIP * FPS;
            for (let f = 0; f < n; f++) {
                octx.clearRect(0, 0, off.width, off.height);

                const vw = cam.videoWidth, vh = cam.videoHeight;
                const sr = vw / vh, dr = off.width / off.height;
                let w, h, x, y;
                if (sr > dr) { h = off.height; w = h * sr; x = (off.width - w) / 2; y = 0; }
                else { w = off.width; h = w / sr; x = 0; y = (off.height - h) / 2; }

                octx.save();
                octx.translate(x + w, y);
                octx.scale(-1, 1);
                octx.drawImage(cam, 0, 0, vw, vh, 0, 0, w, h);
                octx.restore();

                // snapshot to a frame canvas
                const frame = document.createElement('canvas');
                frame.width = off.width; frame.height = off.height;
                frame.getContext('2d').drawImage(off, 0, 0);
                frames[i].push(frame);

                await new Promise(r => setTimeout(r, 1000 / FPS));
            }
        }

        async function recordAll() {
            frames[0] = []; frames[1] = []; frames[2] = [];
            dl.classList.add('hidden'); previewBtn.disabled = true; downloadBtn.disabled = true;
            bar.style.width = '0%'; statusEl.textContent = 'Starting camera…';

            await setupCamera();

            mode = 'recording';
            for (let i = 0; i < 3; i++) {
                currentPose = i;
                statusEl.textContent = `Pose ${i + 1}: Get ready!`;
                await countdown(LEAD, `Pose ${i + 1} in`);
                statusEl.textContent = `Pose ${i + 1}: Recording…`;
                await captureClip(i);
                bar.style.width = `${Math.round(((i + 1) / 3) * 100)}%`;
            }
            currentPose = -1;
            mode = 'idle';

            statusEl.textContent = 'Captured! You can preview or export the GIF.';
            previewBtn.disabled = false; downloadBtn.disabled = false;
        }

        async function previewPlayback() {
            const total = CLIP * FPS; let f = 0;

            const step = () => {
                drawCompositedFrameIndex(f);
                f = (f + 1) % total;
                if (previewBtn.dataset.playing === 'true') {
                    setTimeout(() => requestAnimationFrame(step), 1000 / FPS);
                } else {
                    mode = 'idle';
                }
            };

            if (previewBtn.dataset.playing === 'true') {
                previewBtn.dataset.playing = 'false';
                previewBtn.textContent = 'Preview GIF';
                mode = 'idle';
            } else {
                previewBtn.dataset.playing = 'true';
                previewBtn.textContent = 'Stop Preview';
                mode = 'preview';
                step();
            }
        }

        async function exportGIF() {
            if (typeof GIF !== 'function') {
                statusEl.textContent = 'GIF encoder not loaded';
                return;
            }
            const total = CLIP * FPS;

            const workerCode = "importScripts('https://cdn.jsdelivr.net/npm/gif.js.optimized@1.0.1/dist/gif.worker.js');";
            const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
            const workerURL = URL.createObjectURL(workerBlob);

            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: geo.W,
                height: geo.H,
                repeat: 0,
                workerScript: workerURL
            });

            gif.on('progress', p => {
                const pct = Math.round(p * 100);
                bar.style.width = pct + '%';
                statusEl.textContent = 'Encoding… ' + pct + '%';
            });

            gif.on('finished', blob => {
                const url = URL.createObjectURL(blob);
                const name = `photobooth_${new Date().toISOString().replace(/[:.]/g, '-')}.gif`;
                const a = document.createElement('a');
                a.href = url; a.download = name;
                document.body.appendChild(a);
                a.click();
                a.remove();
                statusEl.textContent = `Saved as ${name}`;
                bar.style.width = '100%';
            });

            // Add frames
            for (let f = 0; f < total; f++) {
                drawCompositedFrameIndex(f);
                gif.addFrame(ctx, { copy: true, delay: Math.round(1000 / FPS) });
            }

            statusEl.textContent = 'Encoding…';
            gif.render();
        }

        // ---------- Events ----------
        startBtn.addEventListener('click', async () => {
            startBtn.disabled = true;
            try { await recordAll(); }
            finally { startBtn.disabled = false; }
        });
        previewBtn.addEventListener('click', previewPlayback);
        downloadBtn.addEventListener('click', exportGIF);

        // Cosmetic self-check
        setTimeout(() => {
            document.getElementById('selfcheck-pill').textContent = 'Self-check: passed';
        }, 200);
    </script>
</body>
</html>

